/*
不过这些“智能”的判断也会带来一些与 C++98的有趣的不兼容性。
比如用户只是想让>>在模板的实例化中表示的是真正的右移,
但C++11会把它解析为模板参数界定符。


template＜int i＞class X{};
 X＜1＞＞5＞x;

如果使用C++98标准进行编译的话，
这个例子 会编译通过，因为编译器认为X＜1＞＞5＞x;中的双尖括号是一个位移操作，
那么最终可以得到一个 形如X＜0＞x的模板实例

而如果使用C++11标准 进行编译，那么程序员会得到一个编译错误的警 告，
因为编译器优先将双尖括号中的第一个＞与X 之后的＜进行了配对。

要避免这样的不兼容性也很简 单，使用圆括号将“1＞＞5”括起来，保证右移操 作优先，就不会出现类似问题了。
*/

