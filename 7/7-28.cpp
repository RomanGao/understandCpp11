/*
C++11中，默 认情况下lambda函数是一个const函数。
按照规 则，一个const的成员函数是不能在函数体中改变 非静态成员变量的值的。
但这里明显编译器对不同传参或捕捉列表的lambda函数执行了不同的规则 有着不同的见解。
其究竟是基于什么样的规则而做 出了这样的决定呢？

但事实上这跟 lambda函数的特别的常量性相关。
这里将lambda函数转化为一个 完整的仿函数，
需要注意的是，lambda函数的函 数体部分，被转化为仿函数之后会成为一个class的 常量成员函数。
const_val_lambda=[=](){val=3;};转变为：
*/

class const_val_lambda
{
public:
    const_val_lambda(int v):val(v){}

   // void operator()()const {val =3;};/*注意：常量成员 函数*/
private:
    int val;
};

/*
对于常量成员函数，其常量的规则跟普通的常 量函数是不同的。
具体而言，对于常量成员函数， 不能在函数体内改变class中任何成员变量
因此，const_val_lambda=[=](){val=3;}编译报错



lambda的捕捉列表中 的变量都会成为等价仿函数的成员变量（如 const_val_lambda中的成员val），
而常量成员函 数（如operator()）中改变其值是不允许的，
因而 按值捕捉的变量在没有声明为mutable的lambda函数中，其值一旦被修改就会导致编译器报错。

而使用引用的方式传递的变量在常量成员函数 中值被更改则不会导致错误。
关于这一点在很多 C++书籍中已经有过讨论。
简单地说，由于函数 const_ref_lambda不会改变引用本身，而只会改变 引用的值，因此编译器将编译通过。
至于按传递参 数的const_param_lambda，就更加不会引起编译 器的“抱怨”了。

准确地讲，现有C++11标准中的lambda等价 的是有常量operator()的仿函数。
因此在使用捕捉 列表的时候必须注意，按值传递方式捕捉的变量是 lambda函数中不可更改的常量
这样的设计有其合理性，改变从上下文中拷贝而来 的临时变量通常不具有任何意义。
绝大多数时候， 临时变量只是用于lambda函数的输入，
如果需要 输出结果到上下文，我们可以使用引用，或者通过 让lambda函数返回值来实现。


此外，lambda函数的mutable修饰符可以消除
其常量性，不过这实际上只是提供了一种语法上的 可能性，现实中应该没有多少需要使用mutable的 lambda函数的地方。
大多数时候，我们使用默认 版本的（非mutable）的lambda函数也就足够了。
*/
