/*
指针空值：从0到NULL，再到 nullptr

NULL可能被定义为字面常量0，或 者是定义为无类型指针（void*）常量。不过无论 采用什么样的定义，我们在使用空值的指针时，都 不可避免地会遇到一些麻烦。让我们先看一个关于 函数重载的例子。
这个例子我们引用自C++11标 准关于nullptr的提案，并进行了少许修改，
*/

#include <stdio.h>

void f(char* c)
{
    printf("char* f(char* )\n");
}

void f(int i)
{
    printf("int f(int )\n");
}

int main()
{
    f(0);
  //  f(NULL); ////注意：如用gcc编译，NULL转化为内部标识 __null，该语句会编译失败
    f((char*)0);
}

/*
，当使用XLC编译器编译以上语句并运 行时，会得到以下结果：

int f(int) 
int f(int)
char* f(char*)

XLC编译器采用了stddef.h头文件中 NULL的定义，即将NULL定义为0。
*/

/*
引起该问题的元凶是字面常量0的二义性，
在 C++98标准中，字面常量0的类型既可以是一个整 型，也可以是一个无类型指针（void*）。
如果程 序员想在代码清单7-1.cpp中调用f(char*)版本的话，则 必须像随后的代码一样，
对字面常量0进行强制类 型转换（(void*)0）并调用，否则编译器总是会优 先把0看作是一个整型常量。


虽然这个问题可以通过修改代码来解决，但为 了避免用户使用上的错误，有的编译器做了比较激 进的改进。
典型的如g++编译器，它直接将NULL转换为编译器内部标识（__null），并在编译时期 做了一些分析，
一旦遇到二义性就停止编译并向用 户报告错误。
虽然这在一定程度上缓解了二义性带 来的麻烦，但由于标准并没有认定NULL为一个编 译时期的标识，
所以也会带来代码移植性的限制。
*/

/*
在C++11新标准中，出于兼容性的考虑，字面 常量0的二义性并没有被消除。
但标准还是为二义 性给出了新的答案，就是nullptr。
在C++11标准 中，nullptr是一个所谓“指针空值类型”的常量。 
指针空值类型被命名为nullptr_t，

typedef decltype(nullptr)nullptr_t;


我们发现， 在现有编译器情况下，使用nullptr_t的时候必须 #include＜cstddef＞
（#include有些头文件也会 间接#include＜cstddef＞，比如＜iostream ＞），
而nullptr则不用。
这大概就是由于nullptr是 关键字，而nullptr_t是通过推导而来的缘故。
*/

