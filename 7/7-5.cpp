/*
此外在C++11标准中，nullptr类型数据所占用
的内存空间大小跟void*相同的，
即： sizeof(nullptr_t)==sizeof(void*)


关于这一点也可能引起疑惑，即是否nullptr就 是(void*)0的一个别名。
不过答案却是否定的，尽 管两者看起来很相似，都可以被转换为任何类型的 指针，但两者在语法层面有着不同的内涵。
nullptr 是一个编译时期的常量，它的名字是一个编译时期 的关键字，能够为编译器所识别。
而(void*)0只是 一个强制转换表达式，其返回的也是一个void*指 针类型。
*/

/*
而且最为重要的是，
在C++语言中，nullptr到 任何指针的转换是隐式的，而(void*)0则必须经过 类型转换后才能使用。
*/

int main() 
{
    //int*px=(void*)0;//编译错误，不能隐式地将无类型指针 转换为int*类型的指针 
    int*py=nullptr; 

    return 0;
}
/*
(void*)0在使用上并不如nullptr方 便。
在nullptr出现之后，程序员大可以忘记 (void*)0，因为nullptr已经足够用了，而且也很好 用

C语言标准中的void*指针是可以隐式转换 为任意指针的，这一点跟C++是不同的。
*/

/*
，我们还注意到C++11标准有一条有趣的
规定，nullptr_t对象的地址可以被用户使用（虽然 看起来好像没什么实用价值）。
但这条规则有一点 例外，就是虽然nullptr也是一个nullptr_t的对象， 
C++11标准却规定用户不能获得nullptr的地址。
其原因主要是因为nullptr被定义为一个右值常量， 取其地址并没有意义.
*/