/*
而如果我们采用仿函数，则不 会有这样的限制
*/


int d = 0;
class healthyFunctor
{
public:
    healthyFunctor(int d):data(d){}
    void operator()() const{}

private:
    int data;
};

int main()
{
    healthyFunctor f(d);
    f();
    return 0;
}

/*
healthyFunctor说明了两者的不同。
更一般地讲，仿函数可以被定义以后在 不同的作用域范围内取得初始值。
这使得仿函数天 生具有了跨作用域共享的特征。
*/

/*
lambda函数被设计的目的，就是要 就地书写，就地使用。
使用lambda的用户，更倾向于在一个屏幕里看到所有的代码，而不是依靠代 码浏览工具在文件间找到函数的实现。
而在封装的 思维层面上，lambda只是一种局部的封装，以及 局部的共享。
而需要全局共享的代码逻辑，我们则 还是需要用函数（无状态）或者仿函数（有状态） 封装起来
*/

/*
简单地总结一下，使用lambda代替仿函数的应 该满足如下一些条件：
 ❑是局限于一个局部作用域中使用的代码逻 辑。
 ❑这些代码逻辑需要被作为参数传递。 
 此外，关于捕捉列表的使用也存在有很多的讨 论。
 由于[=],[＆]这些写法实在是太过方便了，有的时候，我们不会仔细思考其带来的影响就开始滥 用，这也会造成一些意想不到的问题。
*/

/*
首先，我们来看一下[=]，除去我们之前提过 的，
所有捕捉的变量在lambda声明一开始就被拷 贝，且拷贝的值不可被更改，这两点需要程序员注 意之外，
还有一点就是拷贝本身。这点跟函数参数 按值方式传递是一样的，如果不想带来过大的传递 开销的话，可以采用引用传递的方式传递参数。


其次，我们再来看一下[＆]。如我们之前提到过 的，通过引用方式传递的对象也会输出到父作用域 中。
同样的，父作用域对这些对象的操作也会传递 到lambda函数中。
因此，如果我们代码存在异步 操作，或者其他可能改变对象的任何操作，我们必
须确定其在父作用域及lambda函数间的关系，否 则也会产生一些错误。

通常情况下，在使用[=]、[＆]这些默认捕捉列 表的时候，我们需要考察其性能、与父作用域如何 关联等。
捕捉列表是lambda最神奇也是最容易犯 错的地方，程序员不能一味图方便了事。
*/