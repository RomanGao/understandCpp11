/*
C++11解决了Unicode类型数据的存储问题。
C++11引入以下两种新的内置数据类型来存储不同编码长度的Unicode数据。
❑char16_t：用于存储UTF-16编码的Unicode 数据。
❑char32_t：用于存储UTF-32编码的Unicode 数据。
至于UTF-8编码的Unicode数据，C++11还是 使用8字节宽度的char类型的数组来保存。
而 char16_t和char32_t的长度则犹如其名称所显示的 那样，长度分别为16字节和32字节，对任何编译 器或者系统都是一样的。

此外，C++11还定义了一些常量字符串的前 缀。
在声明常量字符串的时候，这些前缀声明可以 让编译器使字符串按照前缀类型产生数据。
事实上，C++11一共定义了3种这样的前缀：
 ❑u8表示为UTF-8编码。 
 ❑u表示为UTF-16编码。
  ❑U表示为UTF-32编码。
3种前缀对应于3种不同的Unicode编码。一旦 声明了这些前缀，编译器会在产生代码的时候按照 相应的编码方式存储。
以上3种前缀加上基于宽字 符wchar_t的前缀“L”，及不加前缀的普通字符串 字面量，算来在C++11中，一共有了5种方式来声 明字符串字面量，其中4种是前缀表达的。

通常情况下，按照C/C++的规则，连续在代码 中声明多个字符串字面量，则编译器会自动将其连 接起来。比如"a""b"这样声明的方式与"ab"的声明
方式毫无区别。而一旦连续声明的多个字符串字面 量中的某一个是前缀的，则不带前缀的字符串字面 量会被认为与带前缀的字符串字面量是同类型的。
 比如声明u "a" "b"和"a" u "b"，其效果跟u "ab"是完全等同的，都是生成了连续的字面量等于 UTF-16编码"ab"的字符串。
不过最好不要将各种 前缀字符串字面量连续声明，因为标准定义除了 UTF-8和宽字符字符串字面量同时声明会冲突外，
 其他字符串字面量的组合最终会产生什么结果，以 及会按照什么类型解释，是由编译器实现自行决定 的。
因此应该尽量避免这种不可移植的字符串字面 量声明方式。


对于Unicode编码字符的书写，C++11中还规
定了一些简明的方式，即在字符串中用'\u'加4个十 六进制数编码的Unicode码位（UTF-16）来标识 一个Unicode字符。
比如'\u4F60'表示的就是 Unicode中的中文字符“你”，而'\u597D'则是 Unicode中的“好”。
此外，也可以通过'\U'后跟8 个十六进制数编码的Unicode码位（UTF-32）的 方式来书写Unicode字面常量。
*/
#include<iostream>
using namespace std;

int main()
{
    char utf8[]=u8"\u4F60\u597D\u554A"; 
    char16_t utf16[]=u"hello"; 
    char32_t utf32[]=U"hello equals\u4F60\u597D\u554A";
    cout<<utf8<<endl;
    cout<<utf16<<endl;
    cout<<utf32<<endl;

  //  char32_t u2[]=u"hello"; //error
 //   char u3[]=U"hello";//Error 
 //   char16_t u4=u8"hello";//Error
    cout<<"hello"<<endl;
    return 0;
}

/*
，我们声明了3种不同类型的Unicode 字符串utf8、utf16和utf32。
由于无论对哪种 Unicode编码，英文的Unicode码位都相同，
因此 只有非英文使用了"\u"的码位方式来标志。
我们可以看到，一旦使用了Unicode字符串前缀，这个字 符串的类型就确定了，
仅能放在相应类型的数组 中。
u2、u3、u4就是因为类型不匹配而不能通过 编译
*/

/*
C++11虽然在语言层面对Unicode进 行了支持，但语言层面并不是唯一的决定因素。
用 户要在自己的系统上看到正确的Unicode文字，还 需要输出环境、编译器，甚至是代码编辑器等的支 持。
我们可以按照编写代码、编译、运行的顺序来 看看它们对整个Unicode字符串输出的影响。
首先会影响Unicode正确性的过程是源文件的 保存。
第二个会影响Unicode正确性的过程是编译。
第三个会影响Unicode正确性的过程是输出。


在现有的编程环境支持下，如果要保证在程序中直接输入中文得到正确的输出，
我们建议程序员 要使用与系统环境中相同的编码方式。
*/