//使用列表初始化还有一个最大优势是可以防止 类型收窄（narrowing）

//类型收窄一般是指一些 可以使得数据变化或者精度丢失的隐式类型转换
//比如将int类型转换为float类型，或者将double类型转换为int类型
//从整型（或者非强类型的枚举）转化为浮点型，如果整型数大到浮点数无法精确地表示，则也 可以视为类型收窄
//，如果变量a从类型A转化为类型 B，其值在B中也是可以被表示的，且再转化回类型 A能获得原有的值的话，那么这种类型转换也不能 叫作类型收窄。
//所以类型收窄也可以简单地理解为 新类型无法表示原有类型数据的值的情况。


//使用初始化列表进行初始化的数据编译器是会检查其是否发生类型收 窄的。

int main(int argc, char const *argv[])
{
    const int x=1024; 
    const int y=10; 
    char a=x;//收窄，但可以通过编译 
    char*b=new char(1024);//收窄，但可以通过编译 
   // char c={x};//收窄，无法通过编译 
    char d={y};//可以通过编译 
    //unsigned char e{-1};//收窄，无法通过编译 
    float f{7};//可以通过编译 
   // int g{2.0f};//收窄，无法通过编译   通 常可以认为，将2.0f转换成整型会丢失精度
  //  float*h=new float{1e48};//收窄，无法通过编译 
    float i=1.2l;//可以通过编译

    return 0;
}


//列表初始化是唯一一种可以防止 类型收窄的初始化方式。这也是列表初始化区别于 其他初始化方式的地方。
//C++11将列 表初始化设定为可以防范类型收窄，也就是为了加 强类型使用的安全性。

