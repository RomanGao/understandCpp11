/*
不过我们可以稍微改造一下目标构造函数， 使得委派构造函数依然可以在初始化列表中初始化

*/

class Info
{ 
public: 
    Info():Info(1,'a'){} 
    Info(int i):Info(i,'a'){} //委托构造函数依托目标构造函数在初始化列表中完成初始化
    Info(char e):Info(1,e){} 
private: 
    Info(int i,char e):type(i),name(e){/*其他初始化 */}
    int type; 
    char name; //... 
};


/*
这个构造函数接受两个 参数，并将参数在初始化列表中初始化。
而且由于 这个目标构造函数的存在，我们可以不再需要InitRest函数了，而是将其代码都放入 Info(int,char)中。
这样一来，其他委派构造函数就 可以委托该目标构造函数来完成构造




在C++11中，目标构造函数的执行总是先于委派构造函数。
因此避免目标构造函数和委托构造 函数体中初始化 同样的成员通常是必要的
*/